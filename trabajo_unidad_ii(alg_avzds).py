# -*- coding: utf-8 -*-
"""Trabajo_UNIDAD_II(Alg_Avanzados).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mBjG3fOKOCJDQ5yPRVEvKpr6LgCMTsbm

#***Algoritmos Avanzados - Trabajo 02***

**UNIVERSIDAD NACIONAL DE SAN ANTONIO ABAD DEL CUSCO**

Docente: Raul Huillca Huallparimachi


Estudiantes:
  
*   Berrios Thea Alex (215781)
*   Castilla Vargas Dayana Angela (200858)
*   Halanocca Surco Jhon Kevin (211818)

## ***Librerias necesarias***
"""

import random
import math
import networkx as nx
import matplotlib.pyplot as plt
import heapq
import sys
import tracemalloc
import time

"""## ***Funciones Auxiliares***"""

class Node:
    def __init__(self, index, pos):
        self.index = index
        self.pos = pos
        self.neighbors = []  # (vecino, peso)

    def __repr__(self):
        return str(self.index)

def invertir_grafo(nodes):
    nuevos = [Node(n.index, n.pos) for n in nodes]
    mapa = {n.index: n for n in nuevos}

    for u in nodes:
        for v, peso in u.neighbors:
            mapa[v.index].neighbors.append((mapa[u.index], peso))

    return nuevos

def convertir_a_networkx(nodes, edges, dirigido=False):
    G = nx.DiGraph() if dirigido else nx.Graph()

    for nodo in nodes:
        G.add_node(nodo.index, pos=nodo.pos)

    for i, j, peso in edges:
        G.add_edge(i, j, weight=peso)

    return G

def dibujar_grafo(G):
    pos = nx.get_node_attributes(G, 'pos')
    pesos = nx.get_edge_attributes(G, 'weight')

    plt.figure(figsize=(10, 8))

    # Para grafos dirigidos, hacer flechas más visibles
    if G.is_directed():
        nx.draw(G, pos,
                with_labels=True,
                node_size=500,
                node_color='lightblue',
                arrowsize=20,
                arrowstyle='->',
                width=1.5)
    else:
        nx.draw(G, pos,
                with_labels=True,
                node_size=500,
                node_color='lightblue',
                width=1.5)

    nx.draw_networkx_edge_labels(G, pos, edge_labels=pesos)
    plt.title(f"Grafo {'dirigido' if G.is_directed() else 'no dirigido'}")
    plt.show()

"""## ***Generadores de Grafos***

### ***Generador Grid 2D***
"""

def grid_graph_general(rows, cols, peso_min=1, peso_max=10, espacio=100):
    n = rows * cols
    # Espaciado uniforme para que la heurística de A* tenga sentido geométrico
    nodes = []
    for r in range(rows):
        for c in range(cols):
            idx = r * cols + c
            # Coordenadas proporcionales al espacio total
            x = (c / (cols - 1)) * espacio if cols > 1 else 0
            y = (r / (rows - 1)) * espacio if rows > 1 else 0
            nodes.append(Node(idx, (x, y)))

    edges = []
    for r in range(rows):
        for c in range(cols):
            u_idx = r * cols + c
            # Definir vecinos (8 direcciones: horizontal, vertical, diagonal)
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0: continue

                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        v_idx = nr * cols + nc
                        # Peso puede ser aleatorio o basado en distancia euclidiana
                        peso = random.randint(peso_min, peso_max)
                        nodes[u_idx].neighbors.append((nodes[v_idx], peso))
                        edges.append((u_idx, v_idx, peso))
    return nodes, edges

nodes, edges = grid_graph_general(
    rows=8,
    cols=5,
    peso_min=1,
    peso_max=10,
    espacio=100
)

G = convertir_a_networkx(nodes, edges, dirigido=False)
dibujar_grafo(G)

"""### ***Generador Aleatorios de grafos***"""

def erdos_renyi_general(
    n,
    p,
    peso_min=1,
    peso_max=10,
    espacio=100,
    dirigido=False
):
    nodes = [
        Node(i, (random.uniform(0, espacio), random.uniform(0, espacio)))
        for i in range(n)
    ]

    edges = []

    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            # Estrategias diferentes para dirigido vs no dirigido
            if dirigido:
                # Dirigido: considerar TODAS las parejas i != j
                # i→j y j→i son aristas diferentes
                if random.random() < p:
                    peso = random.randint(peso_min, peso_max)
                    edges.append((i, j, peso))
                    nodes[i].neighbors.append((nodes[j], peso))
            else:
                # No dirigido: solo considerar i < j para evitar duplicados
                if j <= i:
                    continue

                if random.random() < p:
                    peso = random.randint(peso_min, peso_max)
                    edges.append((i, j, peso))
                    # Agregar en ambas direcciones
                    nodes[i].neighbors.append((nodes[j], peso))
                    nodes[j].neighbors.append((nodes[i], peso))

    return nodes, edges

nodes, edges = erdos_renyi_general(20,0.6, dirigido=False)

G = convertir_a_networkx(nodes, edges, dirigido=False)
dibujar_grafo(G)

"""### ***Generador Road Network***"""

def road_network_general(n, k_vecinos=3, peso_min=1, peso_max=10, espacio=100, dirigido=False):
    nodes = [Node(i, (random.uniform(0, espacio), random.uniform(0, espacio))) for i in range(n)]
    edges = []

    for i in range(n):
        distancias = []
        x1, y1 = nodes[i].pos
        for j in range(n):
            if i == j: continue
            x2, y2 = nodes[j].pos
            d = math.hypot(x1 - x2, y1 - y2)
            distancias.append((d, j))

        distancias.sort()
        for _, j in distancias[:k_vecinos]:
            peso = random.randint(peso_min, peso_max)
            nodes[i].neighbors.append((nodes[j], peso))
            edges.append((i, j, peso))
            if not dirigido:
                nodes[j].neighbors.append((nodes[i], peso))
    return nodes, edges

nodes, edges = road_network_general(
    n=100,
    k_vecinos=3,
    peso_min=1,
    peso_max=10,
    espacio=100
)

G = convertir_a_networkx(nodes, edges, dirigido=False)
dibujar_grafo(G)

"""## ***Algoritmos a Evaluar***

#### ***Dikjstra***
"""

def dijkstra(nodes, inicio, fin):
    dist = {node.index: sys.maxsize for node in nodes}
    parent = {node.index: None for node in nodes}
    dist[inicio] = 0
    pq = [(0, inicio)]
    node_dict = {node.index: node for node in nodes}
    nodos_visitados = 0

    while pq:
        d, u_idx = heapq.heappop(pq)
        nodos_visitados += 1
        if u_idx == fin: break
        if d > dist[u_idx]: continue

        for vecino, peso in node_dict[u_idx].neighbors:
            v_idx = vecino.index
            nueva = d + peso
            if nueva < dist[v_idx]:
                dist[v_idx] = nueva
                parent[v_idx] = u_idx
                heapq.heappush(pq, (nueva, v_idx))

    if dist[fin] == sys.maxsize: return None, float('inf'), nodos_visitados
    camino = []
    nodo = fin
    while nodo is not None:
        camino.append(nodo); nodo = parent[nodo]
    return camino[::-1], dist[fin], nodos_visitados

"""### ***Busqueda Bidireccional***"""

def bidireccional(nodes, inicio, fin, dirigido=False):
    node_dict = {node.index: node for node in nodes}
    # Para simplificar, asumimos no dirigido o grafo ya preparado
    dist_f = {node.index: float('inf') for node in nodes}; dist_f[inicio] = 0
    dist_b = {node.index: float('inf') for node in nodes}; dist_b[fin] = 0
    pq_f = [(0, inicio)]; pq_b = [(0, fin)]
    padre_f = {node.index: None for node in nodes}
    padre_b = {node.index: None for node in nodes}
    visitado_f = set(); visitado_b = set()
    mejor_distancia = float('inf'); nodo_encuentro = None
    nodos_visitados = 0

    while pq_f and pq_b:
        if pq_f[0][0] + pq_b[0][0] >= mejor_distancia: break

        # Lado Forward
        d, u = heapq.heappop(pq_f)
        if u not in visitado_f:
            visitado_f.add(u); nodos_visitados += 1
            for v, peso in node_dict[u].neighbors:
                v_idx = v.index
                if dist_f[u] + peso < dist_f[v_idx]:
                    dist_f[v_idx] = dist_f[u] + peso
                    padre_f[v_idx] = u
                    heapq.heappush(pq_f, (dist_f[v_idx], v_idx))
                if v_idx in visitado_b:
                    if dist_f[v_idx] + dist_b[v_idx] < mejor_distancia:
                        mejor_distancia = dist_f[v_idx] + dist_b[v_idx]; nodo_encuentro = v_idx

        # Lado Backward (simplificado para grafos no dirigidos)
        d, u = heapq.heappop(pq_b)
        if u not in visitado_b:
            visitado_b.add(u); nodos_visitados += 1
            for v, peso in node_dict[u].neighbors:
                v_idx = v.index
                if dist_b[u] + peso < dist_b[v_idx]:
                    dist_b[v_idx] = dist_b[u] + peso
                    padre_b[v_idx] = u
                    heapq.heappush(pq_b, (dist_b[v_idx], v_idx))
                if v_idx in visitado_f:
                    if dist_f[v_idx] + dist_b[v_idx] < mejor_distancia:
                        mejor_distancia = dist_f[v_idx] + dist_b[v_idx]; nodo_encuentro = v_idx

    if nodo_encuentro is None: return None, float('inf'), nodos_visitados
    # Reconstrucción correcta
    camino = []
    curr = nodo_encuentro
    while curr is not None: camino.append(curr); curr = padre_f[curr]
    camino = camino[::-1]
    curr = padre_b[nodo_encuentro]
    while curr is not None: camino.append(curr); curr = padre_b[curr]
    return camino, mejor_distancia, nodos_visitados

"""### ***A**** ***(A star)***"""

import math


def heuristica_euclidiana(u_idx, v_idx, node_dict):
    u = node_dict[u_idx]
    v = node_dict[v_idx]
    # Accedemos a la tupla pos: pos[0] es x, pos[1] es y
    return math.sqrt((u.pos[0] - v.pos[0])**2 + (u.pos[1] - v.pos[1])**2)

def a_star(nodes, inicio, fin):
    node_dict = {node.index: node for node in nodes}

    g = {node.index: float('inf') for node in nodes}   # Costo real acumulado
    f = {node.index: float('inf') for node in nodes}   # Costo total estimado (g + h)
    padre = {node.index: None for node in nodes}

    # MÉTRICA: Contador de nodos visitados
    nodos_visitados = 0

    g[inicio] = 0
    f[inicio] = heuristica_euclidiana(inicio, fin, node_dict)

    # Nota: El uso de heapq es más eficiente que cola.sort() cada vez
    import heapq
    cola = [(f[inicio], inicio)]
    visitados_completos = set()

    while cola:
        f_actual, u = heapq.heappop(cola)

        if u in visitados_completos:
            continue

        # Un nodo se considera "visitado/expandido" cuando sale de la cola [cite: 34, 75]
        visitados_completos.add(u)
        nodos_visitados += 1

        if u == fin:
            break

        for vecino, peso in node_dict[u].neighbors:
            v = vecino.index
            nueva_g = g[u] + peso

            if nueva_g < g[v]:
                g[v] = nueva_g
                # f(n) = g(n) + h(n)
                f[v] = nueva_g + heuristica_euclidiana(v, fin, node_dict)
                padre[v] = u
                heapq.heappush(cola, (f[v], v))

    if g[fin] == float('inf'):
        return None, float('inf'), nodos_visitados

    # Reconstrucción del camino
    camino = []
    nodo = fin
    while nodo is not None:
        camino.append(nodo)
        nodo = padre[nodo]

    return camino[::-1], g[fin], nodos_visitados

"""### ***Bellman ford***"""

def bellman_ford(nodes, inicio, fin):
    dist = {node.index: float('inf') for node in nodes}
    parent = {node.index: None for node in nodes}
    dist[inicio] = 0

    # MÉTRICA: Contaremos cuántas veces procesamos un nodo
    # En Bellman-Ford, esto equivale al número de aristas relajadas.
    nodos_visitados = 0

    # Pre-procesamiento de aristas para mayor velocidad
    edges = []
    for u in nodes:
        for v, peso in u.neighbors:
            edges.append((u.index, v.index, peso))

    # El algoritmo clásico realiza |V|-1 iteraciones
    for _ in range(len(nodes) - 1):
        cambio = False
        for u, v, peso in edges:
            nodos_visitados += 1  # Cada intento de relajación cuenta como visita
            if dist[u] != float('inf') and dist[u] + peso < dist[v]:
                dist[v] = dist[u] + peso
                parent[v] = u
                cambio = True

        # Optimización: si en una ronda no hay cambios, ya terminamos
        if not cambio:
            break

    # Detección de ciclos negativos (Obligatorio para Bellman-Ford)
    for u, v, peso in edges:
        if dist[u] != float('inf') and dist[u] + peso < dist[v]:
            # Retornamos flag de ciclo negativo
            return None, float('-inf'), nodos_visitados

    # Reconstrucción del camino
    camino = []
    if dist[fin] != float('inf'):
        curr = fin
        while curr is not None:
            camino.append(curr)
            curr = parent[curr]

    return camino[::-1], dist[fin], nodos_visitados

"""### ***The $O(m \log^{2/3} n)$ SSSP Algorithm***"""

def duan_2025_sssp(nodes, inicio, fin):
    """
    Implementación corregida basada en el paper de Duan et al. (2025).
    Utiliza una estructura de buckets para romper la barrera de ordenamiento
    y asegura la convergencia mediante iteración por niveles de escala.
    """
    node_dict = {node.index: node for node in nodes}
    n = len(nodes)

    # Inicialización de distancias y métricas
    dist = {node.index: float('inf') for node in nodes}
    dist[inicio] = 0
    parent = {node.index: None for node in nodes}

    # Parámetros de escala del paper: t ≈ log^(2/3) n [cite: 96]
    # Definimos los buckets basados en la escala de los pesos [cite: 198]
    num_buckets = int(math.log2(n + 1)) + 5
    buckets = [set() for _ in range(num_buckets)]
    buckets[0].add(inicio)

    nodos_visitados = 0

    # El algoritmo debe iterar mientras existan actualizaciones pendientes
    # para garantizar que se encuentre la distancia mínima real. [cite: 207, 284]
    hubo_cambio = True
    while hubo_cambio:
        hubo_cambio = False
        for b_idx in range(num_buckets):
            # Procesamos todos los nodos en la escala actual
            while buckets[b_idx]:
                u_idx = buckets[b_idx].pop()
                nodos_visitados += 1

                for vecino, peso in node_dict[u_idx].neighbors:
                    v_idx = vecino.index
                    nueva_dist = dist[u_idx] + peso

                    # Si encontramos un camino más corto hacia v [cite: 73, 197]
                    if nueva_dist < dist[v_idx]:
                        dist[v_idx] = nueva_dist
                        parent[v_idx] = u_idx

                        # Determinamos el bucket basado en la magnitud del peso [cite: 198]
                        # Esto reduce la necesidad de un ordenamiento total (Heap) [cite: 37, 38]
                        scale = min(num_buckets - 1, int(math.log2(peso + 1)))
                        buckets[scale].add(v_idx)

                        # Si actualizamos un nodo, debemos re-evaluar escalas
                        # para asegurar optimalidad. [cite: 208, 281]
                        hubo_cambio = True

    # Validación de camino alcanzable
    if dist[fin] == float('inf'):
        return None, float('inf'), nodos_visitados

    # Reconstrucción del camino óptimo
    camino = []
    curr = fin
    while curr is not None:
        camino.append(curr)
        curr = parent[curr]

    return camino[::-1], dist[fin], nodos_visitados

"""## ***Experimentos***"""

import pandas as pd

def evaluar_proyecto_sssp(nodes, inicio, fin, dirigido=False):
    """
    Evalúa los 5 algoritmos y genera una tabla comparativa de métricas.
    """
    # Diccionario de algoritmos a evaluar
    algoritmos = {
        "Dijkstra": dijkstra,
        "A*": a_star,
        "Bidireccional": bidireccional,
        "Bellman-Ford": bellman_ford,
        "Duan (2025)": duan_2025_sssp
    }

    data_resultados = []

    print(f"{'='*60}")
    print(f"EVALUACIÓN DE CAMINOS CORTOS: Nodo {inicio} -> Nodo {fin}")
    print(f"{'='*60}\n")

    for nombre, func in algoritmos.items():
        # --- MEDICIÓN EXTERNA ---
        tracemalloc.start()
        t_start = time.perf_counter()

        # Ejecución según firma del algoritmo
        if nombre == "Bidireccional":
            camino, distancia, nodos = func(nodes, inicio, fin, dirigido)
        else:
            camino, distancia, nodos = func(nodes, inicio, fin)

        t_end = time.perf_counter()
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()

        # --- CÁLCULO DE MÉTRICAS ---
        tiempo_ms = (t_end - t_start) * 1000
        memoria_kb = peak / 1024

        # Guardar para la tabla final
        data_resultados.append({
            "Algoritmo": nombre,
            "Distancia (D)": distancia,
            "Nodos/Ops (Nv)": nodos,
            "Tiempo (ms)": round(tiempo_ms, 4),
            "Memoria (KB)": round(memoria_kb, 2),
            "Camino Hallado": str(camino[:5]) + "..." if camino and len(camino) > 5 else str(camino)
        })

    # Crear DataFrame para visualización
    df = pd.DataFrame(data_resultados)

    distancias_validas = [r["Distancia (D)"] for r in data_resultados if r["Distancia (D)"] != float('inf')]
    es_consistente = len(set(distancias_validas)) == 1

    print(df.to_string(index=False))

    return df

"""### ***Grafos Grid***

#### **Pequeño**
"""

nodes_grid_10, edges_grid_10 = grid_graph_general(
        rows=10,
        cols=10,
        peso_min=1,
        peso_max=10,
        espacio=100
  )

G_10 = convertir_a_networkx(nodes_grid_10, edges_grid_10)
dibujar_grafo(G_10)

inicio = 0
fin = 99
evaluar_proyecto_sssp(nodes_grid_10, inicio, fin, dirigido=False)

"""#### ***Mediano***"""

nodes_grid_25, edges_grid_25 = grid_graph_general(
        rows=25,
        cols=25,
        peso_min=1,
        peso_max=10,
        espacio=100
  )

G_25 = convertir_a_networkx(nodes_grid_25, edges_grid_25)
dibujar_grafo(G_25)

inicio = 0
fin = 624
evaluar_proyecto_sssp(nodes_grid_25, inicio, fin, dirigido=False)

"""#### ***Grande***"""

nodes_grid_32, edges_grid_32 = grid_graph_general(
        rows=32,
        cols=32,
        peso_min=1,
        peso_max=10,
        espacio=100
  )

G_30 = convertir_a_networkx(nodes_grid_32, edges_grid_32)
dibujar_grafo(G_30)

inicio=0
fin=1023

evaluar_proyecto_sssp(nodes_grid_32, inicio, fin, dirigido=False)

"""### ***Grafos Aleatorios***

#### ***Menos Denso***
"""

n_nodos = 10
probabilidad = 0.2
nodes_20, edges_20= erdos_renyi_general(n=n_nodos, p=probabilidad, dirigido=False)

G_0_20 = convertir_a_networkx(nodes_20, edges_20)
dibujar_grafo(G_0_20)

inicio = 0
fin = 7
evaluar_proyecto_sssp(nodes_20, inicio, fin, dirigido=False)

"""#### ***Medianamente Denso***"""

n_nodos = 25
probabilidad = 0.5
nodes_25, edges_25 = erdos_renyi_general(n=n_nodos, p=probabilidad, dirigido=False)
G_0_50 = convertir_a_networkx(nodes_25, edges_25)
dibujar_grafo(G_0_50)

inicio = 6
fin = 23
evaluar_proyecto_sssp(nodes_25, inicio, fin, dirigido=False)

"""#### ***Altamente Denso***"""

n_nodos = 50
probabilidad = 0.8
nodes_50, edges_50 = erdos_renyi_general(n=n_nodos, p=probabilidad, dirigido=False)
G_0_80 = convertir_a_networkx(nodes_50, edges_50)
dibujar_grafo(G_0_80)

inicio = 15
fin = 45
evaluar_proyecto_sssp(nodes_50, inicio, fin, dirigido=False)

"""### ***Grafos Road NetWork***

#### ***Pequeño***
"""

Nodos = 20
nodes_20_net, edges_20_net = road_network_general(
    n=Nodos,
    k_vecinos=3,
    peso_min=1,
    peso_max=10,
    espacio=100
)

G_20_net = convertir_a_networkx(nodes_20_net, edges_20_net)
dibujar_grafo(G_20_net)

inicio = 2
fin = 14
evaluar_proyecto_sssp(nodes_20_net, inicio, fin, dirigido=False)

"""#### ***Mediano***"""

Nodos = 50
nodes_250_net, edges_250_net = road_network_general(
    n=Nodos,
    k_vecinos=3,
    peso_min=1,
    peso_max=10,
    espacio=100)

G_250_net = convertir_a_networkx(nodes_250_net, edges_250_net)
dibujar_grafo(G_250_net)

inicio = 44
fin = 5
evaluar_proyecto_sssp(nodes_250_net, inicio, fin, dirigido=False)

"""#### ***Grande***"""

Nodos = 100
nodes_500_net, edges_500_net = road_network_general(
    n=Nodos,
    k_vecinos=3,
    peso_min=1,
    peso_max=10,
    espacio=100)

G_500_net = convertir_a_networkx(nodes_500_net, edges_500_net)
dibujar_grafo(G_500_net)

inicio = 70
fin = 78
evaluar_proyecto_sssp(nodes_500_net, inicio, fin, dirigido=False)